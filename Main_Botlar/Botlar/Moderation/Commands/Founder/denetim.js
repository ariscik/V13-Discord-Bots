const { roleBackup, channelBackup } = require("../../../../Helpers/Schemas")
const { rolKur } = require("../../../../Helpers/BackupFunction");
class Denetim extends Command {
    constructor(client) {
        super(client, {
            name: "denetim",
            aliases: ["denetim", "silinen"],
            Founder: true,
        });
    }
    async run(client, message, args, embed) {
        if (!args[0] || !args[0].toLowerCase() === "rol" && !args[0].toLowerCase() === "kanal") return message.reply({ embeds: [embed.setDescription(`Lütfen \`rol/kanal\` olmak üzere geçerli bir eylem belirtiniz ${emojis.iptal}\n\n\`Son 1 saatte silinen rol&kanal için .denetim rol/kanal 1 veya hepsine bakmak için .denetim rol/kanal\``)] })
        if (args[0].toLowerCase() === "rol") {
            if (args[1] === "1") {
                const entries = await message.guild.fetchAuditLogs({ type: 'ROLE_DELETE', limit: 10 }).then((audit) => audit.entries); const entriess = entries.filter(e => Date.now() - e.createdTimestamp < 1000 * 60 * 60); if (!entriess.size) return message.channel.send(`**UYARI :** Merhaba! Son 1 saatte silinmiş hiç bir rol bulunamadı!`).sil(10)
                const row = new Discord.MessageActionRow().addComponents(new Discord.MessageSelectMenu().setCustomId('select').setPlaceholder('Silinen Roller!').addOptions(entriess.map((entry) => { const name = entry.changes.find((change) => change.key === 'name') || { old: 'new-role' }; return { label: name.old, description: entry.executor.tag, value: entry.id, }; })));
                const denetimmsg = await message.channel.send({ embeds: [embed.setDescription(`Merhaba ${message.author}! Aşağıdaki menülerden silinen son 10 rolü görebilirsin!`)], components: [row], });
                denetimmsg.awaitMessageComponent({ filter: (component) => component.user.id === message.author.id, componentType: 'SELECT_MENU', }).then(async (interaction) => { const entry = entries.find((entry) => entry.id === interaction.values[0]); await roleBackup.findOne({ roleID: entry.target.id }, async (err, data) => { if (!data) return message.reply(`**UYARI:** Belirtilen rol ID'sine ait veri bulunamadı!`).sil(10); const newRole = await message.guild.roles.create({ name: data.name, color: data.color, hoist: data.hoist, permissions: data.permissions, position: data.position, mentionable: data.mentionable, reason: "Rol Silindiği İçin Tekrar Oluşturuldu!" }); rolKur(entry.target.id, newRole) }); interaction.deferUpdate(); })
            }
            if (!args[1] || args[1] === "all" || args[1] === "hepsi") {
                const entries = await message.guild.fetchAuditLogs({ type: 'ROLE_DELETE', limit: 10 }).then((audit) => audit.entries); if (!entries.size) return message.channel.send(`**UYARI : **Malesef silinen rol bulunamadı!`);
                const row = new Discord.MessageActionRow().addComponents(new Discord.MessageSelectMenu().setCustomId('select').setPlaceholder('Silinen Roller!').addOptions(entries.map((entry) => { const name = entry.changes.find((change) => change.key === 'name') || { old: 'new-role' }; return { label: name.old, description: entry.executor.tag, value: entry.id, }; })));
                const denetimmsg = await message.channel.send({ embeds: [embed.setDescription(`Merhaba ${message.author}! Aşağıdaki menülerden silinen son 10 rolü görebilirsin!`)], components: [row], });
                denetimmsg.awaitMessageComponent({ filter: (component) => component.user.id === message.author.id, componentType: 'SELECT_MENU', }).then(async (interaction) => { const entry = entries.find((entry) => entry.id === interaction.values[0]); await roleBackup.findOne({ roleID: entry.target.id }, async (err, data) => { if (!data) return message.reply(`**UYARI:** Belirtilen rol ID'sine ait veri bulunamadı!`).sil(20); const newRole = await message.guild.roles.create({ name: data.name, color: data.color, hoist: data.hoist, permissions: data.permissions, position: data.position, mentionable: data.mentionable, reason: "Rol Silindiği İçin Tekrar Oluşturuldu!" }); rolKur(entry.target.id, newRole) }); interaction.deferUpdate(); })
            }
        } else if (args[0].toLowerCase() === "kanal") {
            if (args[1] === "1") {
                const entries = await message.guild.fetchAuditLogs({ type: 'CHANNEL_DELETE', limit: 10 }).then((audit) => audit.entries); const entriess = entries.filter(e => Date.now() - e.createdTimestamp < 1000 * 60 * 60); if (!entriess.size) return message.channel.send(`**UYARI :** Son 1 saatte silinmiş mesaj bulunamadı!`).sil(20);
                const row = new Discord.MessageActionRow().addComponents(new Discord.MessageSelectMenu().setCustomId('select2').setPlaceholder('Silinen Kanallar!').addOptions(entriess.map((entry) => { const name = entry.changes.find((change) => change.key === 'name') || { old: 'new-channel' }; return { label: name.old, description: entry.executor.tag, value: entry.id, }; })));
                const denetimmsg = await message.channel.send({ embeds: [embed.setDescription(`Merhaba ${message.author}! Aşağıdaki menülerden silinen son 10 kanalı görebilirsin!`)], components: [row] });
                denetimmsg.awaitMessageComponent({ filter: (component) => component.user.id === message.author.id, componentType: 'SELECT_MENU', }).then(async (interaction) => {
                    const entry = entries.find((entry) => entry.id === interaction.values[0]); const type = entry.changes.find((change) => change.key === 'type') || { old: '0' }; if (type.old === 2) {
                        channelBackup.findOne({ channelID: entry.target.id }, async (err, data) => { if (!data) return message.reply(`**UYARI:** Belirtilen kanal ID'sine ait veri bulunamadı!`).sil(10); const newChannel = await message.guild.channels.create(data.name, { type: 'GUILD_VOICE', bitrate: data.bitrate, parentID: data.parentID, position: data.position + 1, }); const newOverwrite = []; for (let index = 0; index < data.overwrites.length; index++) { const veri = data.overwrites[index]; newOverwrite.push({ id: veri.id, allow: new Discord.Permissions(veri.allow).toArray(), deny: new Discord.Permissions(veri.deny).toArray() }); } await newChannel.permissionOverwrites.set(newOverwrite); data.channelID = newChannel.id; data.save() });
                    } else if (type.old === 0) {
                        channelBackup.findOne({ channelID: entry.target.id }, async (err, data) => { if (!data) return message.channel.send({ embeds: [embed.setDescription("Belirtilen kanal ID'sine ait veri bulunamadı!")] }); const newChannel = await message.guild.channels.create(data.name, { type: 'GUILD_TEXT', nsfw: data.nsfw, parentID: data.parentID, position: data.position + 1, rateLimit: data.rateLimit, }); await message.channel.send({ embeds: [embed.setDescription(`**${newChannel.name}** isimli kanal yedeği kuruluyor...`)] }); const newOverwrite = []; for (let index = 0; index < data.overwrites.length; index++) { const veri = data.overwrites[index]; newOverwrite.push({ id: veri.id, allow: new Discord.Permissions(veri.allow).toArray(), deny: new Discord.Permissions(veri.deny).toArray() }); } await newChannel.permissionOverwrites.set(newOverwrite); data.channelID = newChannel.id; data.save() });
                    } else if (type.old === 4) { channelBackup.findOne({ channelID: entry.target.id }, async (err, data) => { if (!data) return message.channel.send({ embeds: [embed.setDescription("Belirtilen kategori ID'sine ait veri bulunamadı!")] }); const newChannel = await message.guild.channels.create(data.name, { type: 'GUILD_CATEGORY', position: data.position, }); await message.channel.send({ embeds: [embed.setDescription(`**${newChannel.name}** isimli kategori yedeği kuruluyor...`)] }); const textChannels = await channelBackup.find({ parentID: entry.target.id }); await channelBackup.updateMany({ parentID: entry.target.id }, { parentID: newChannel.id }); textChannels.forEach(c => { const textChannel = message.guild.channels.cache.get(c.channelID); if (textChannel) textChannel.setParent(newChannel, { lockPermissions: false }); }); const voiceChannels = await channelBackup.find({ parentID: entry.target.id }); await channelBackup.updateMany({ parentID: entry.target.id }, { parentID: newChannel.id }); voiceChannels.forEach(c => { const voiceChannel = message.guild.channels.cache.get(c.channelID); if (voiceChannel) voiceChannel.setParent(newChannel, { lockPermissions: false }); }); const newOverwrite = []; for (let index = 0; index < data.overwrites.length; index++) { const veri = data.overwrites[index]; newOverwrite.push({ id: veri.id, allow: new Discord.Permissions(veri.allow).toArray(), deny: new Discord.Permissions(veri.deny).toArray() }); } await newChannel.permissionOverwrites.set(newOverwrite); data.channelID = newChannel.id; data.save() }); } interaction.deferUpdate();
                })
            }
            if (!args[1] || args[1] === "all" || args[1] === "hepsi") {
                const entries = await message.guild.fetchAuditLogs({ type: 'CHANNEL_DELETE', limit: 10 }).then((audit) => audit.entries); if (!entries.size) return message.channel.send(`**UYARI :** Son bir saatte silinmiş kanal bulunamadı!`).sil(5)
                const row = new Discord.MessageActionRow().addComponents(new Discord.MessageSelectMenu().setCustomId('select2').setPlaceholder('Silinen Kanallar!').addOptions(entries.map((entry) => { const name = entry.changes.find((change) => change.key === 'name') || { old: 'new-channel' }; return { label: name.old, description: entry.executor.tag, value: entry.id, }; })));
                const denetimmsg = await message.channel.send({ embeds: [embed.setDescription(`Merhaba ${message.author}! Aşağıdaki menülerden silinen son 10 kanalı görebilirsin!`)], components: [row] });
                denetimmsg.awaitMessageComponent({ filter: (component) => component.user.id === message.author.id, componentType: 'SELECT_MENU', }).then(async (interaction) => {
                    const entry = entries.find((entry) => entry.id === interaction.values[0]); const type = entry.changes.find((change) => change.key === 'type') || { old: '0' }; if (type.old === 2) {
                        channelBackup.findOne({ channelID: entry.target.id }, async (err, data) => { if (!data) return message.reply(`**UYARI:** Belirtilen kanal ID'sine ait veri bulunamadı!`).sil(10); const newChannel = await message.guild.channels.create(data.name, { type: 'GUILD_VOICE', bitrate: data.bitrate, parentID: data.parentID, position: data.position + 1, }); const newOverwrite = []; for (let index = 0; index < data.overwrites.length; index++) { const veri = data.overwrites[index]; newOverwrite.push({ id: veri.id, allow: new Discord.Permissions(veri.allow).toArray(), deny: new Discord.Permissions(veri.deny).toArray() }); } await newChannel.permissionOverwrites.set(newOverwrite); data.channelID = newChannel.id; data.save() });
                    } else if (type.old === 0) {
                        channelBackup.findOne({ channelID: entry.target.id }, async (err, data) => { if (!data) return message.channel.send({ embeds: [embed.setDescription("Belirtilen kanal ID'sine ait veri bulunamadı!")] }); const newChannel = await message.guild.channels.create(data.name, { type: 'GUILD_TEXT', nsfw: data.nsfw, parentID: data.parentID, position: data.position + 1, rateLimit: data.rateLimit, }); await message.channel.send({ embeds: [embed.setDescription(`**${newChannel.name}** isimli kanal yedeği kuruluyor...`)] }); const newOverwrite = []; for (let index = 0; index < data.overwrites.length; index++) { const veri = data.overwrites[index]; newOverwrite.push({ id: veri.id, allow: new Discord.Permissions(veri.allow).toArray(), deny: new Discord.Permissions(veri.deny).toArray() }); } await newChannel.permissionOverwrites.set(newOverwrite); data.channelID = newChannel.id; data.save() });
                    } else if (type.old === 4) { channelBackup.findOne({ channelID: entry.target.id }, async (err, data) => { if (!data) return message.channel.send({ embeds: [embed.setDescription("Belirtilen kategori ID'sine ait veri bulunamadı!")] }); const newChannel = await message.guild.channels.create(data.name, { type: 'GUILD_CATEGORY', position: data.position, }); await message.channel.send({ embeds: [embed.setDescription(`**${newChannel.name}** isimli kategori yedeği kuruluyor...`)] }); const textChannels = await channelBackup.find({ parentID: entry.target.id }); await channelBackup.updateMany({ parentID: entry.target.id }, { parentID: newChannel.id }); textChannels.forEach(c => { const textChannel = message.guild.channels.cache.get(c.channelID); if (textChannel) textChannel.setParent(newChannel, { lockPermissions: false }); }); const voiceChannels = await channelBackup.find({ parentID: entry.target.id }); await channelBackup.updateMany({ parentID: entry.target.id }, { parentID: newChannel.id }); voiceChannels.forEach(c => { const voiceChannel = message.guild.channels.cache.get(c.channelID); if (voiceChannel) voiceChannel.setParent(newChannel, { lockPermissions: false }); }); const newOverwrite = []; for (let index = 0; index < data.overwrites.length; index++) { const veri = data.overwrites[index]; newOverwrite.push({ id: veri.id, allow: new Discord.Permissions(veri.allow).toArray(), deny: new Discord.Permissions(veri.deny).toArray() }); } await newChannel.permissionOverwrites.set(newOverwrite); data.channelID = newChannel.id; data.save() }); } interaction.deferUpdate();
                })
            }
        } if (args[0] == 'liste') {
            if (args[1] == 'kanal') {
                const audit = await message.guild.fetchAuditLogs({ type: 'CHANNEL_DELETE' }).then(a => a.entries)
                const denetim = audit.filter(e => Date.now() - e.createdTimestamp < 1000 * 60 * 60 * 24).map(e => message.channel.send(`Kanal id: ${e.target.id} Kanal İsim: ${e.changes.filter(e => e.key === 'name').map(e => e.old)}`))
                if (!denetim.length) return message.channel.send({ embeds: [embed.setDescription(`Son 24 saat de silinmiş herhangi bir kanal bulunamadı!`)] })
            } else if (args[1] == 'rol') {
                const audit = await message.guild.fetchAuditLogs({ type: 'ROLE_DELETE' }).then(a => a.entries)
                const denetim = audit.filter(e => Date.now() - e.createdTimestamp < 1000 * 60 * 60 * 24).map(e => message.channel.send(`Rol id: ${e.target.id} Rol İsim: ${e.changes.filter(e => e.key === 'name').map(e => e.old)}`))
                if (!denetim.length) return message.channel.send({ embeds: [embed.setDescription(`Son 24 saat de silinmiş herhangi bir rol bulunamadı!`)] })
            }
        }
    }
}

module.exports = Denetim